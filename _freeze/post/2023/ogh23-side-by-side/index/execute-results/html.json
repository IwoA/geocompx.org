{
  "hash": "b50e8457116660b490c693d48ccc003a",
  "result": {
    "markdown": "---\ntitle: \"Geographic data analysis in R and Python: comparing code and outputs for vector data (side-by-side version)\"\n# # Alternative title:\n# title: \"Teaching R and Python for geographic data: shared experiences and lessons learned\"\nauthor: \n  - name: Robin Lovelace\n    affiliation: University of Leeds, Active Travel England, UK\n    orcid: 0000-0001-5679-6536\n  - name: Anita Graser\n    affiliation: Austrian Institute of Technology, Austria\n    orcid: 0000-0001-5361-2885\n  - name: Michael Dorman\n    affiliation: Ben-Gurion University of the Negev, Israel\n    orcid: 0000-0001-6450-8047\n  - name: Jakub Nowosad\n    affiliation: Adam Mickiewicz University, Pozna≈Ñ, Poland\n    orcid: 0000-0002-1057-3721\ndate: \"2023-08-30\"\nslug: ogh2023-r-py-side\ncategories: \n  - posts\n  - rstats\n  - python\ntags: [rspatial, geopython]\ndraft: false\n---\n\n\n\n\n# Introduction\n\nIn this blog post, we talk about our experience teaching R and Python for geocomputation.\nThe focus of the blog post is on geographic vector data, meaning points, lines, polygons (and their 'multi' variants) and the attributes associated with them.\nGeographic data analysis is a broad topic and in a later post we will cover raster data, meaning gridded data such as satellite images.\n\n <!---\n broadly defined as [follows](https://r.geocompx.org/intro#what-is-geocomputation):\n\n> Working with geographic data in a computational way, focusing on code, reproducibility and modularity. \n--->\nThe context of this blog post is the [OpenGeoHub Summer School 2023](https://opengeohub.org/summer-school/opengeohub-summer-school-poznan-2023/) which has courses on R, Python and Julia.\nThe size and the diversity of the event has grown over the years.\nNoting that many events focus on just one language, and the advantages of diversity of languages and approaches, we wanted to follow-up in a blog post that could be useful to others.\n\nOpenGeoHub 2023 was also a unique chance for the authors of the in-progress open source book, [Geocomputation with Python](https://py.geocompx.org/) to meet in person: the first time we have all been in one place at the same time.\n\nThe post is based on the following lecture notes, which we recommend checking out for deeper dives into the R and Python implementations of geocomputation:\n\n- [Tidy geographic data with sf, dplyr, ggplot2, geos and friends](https://ogh23.robinlovelace.net/tidy)\n- [Working with spatial data in Python](https://geobgu.xyz/presentations/p_2023_ogh/)\n\n<!---\n TODO: Add video links \n--->\n\n# Comparing R and Python for vector geographic data analysis\n\n## Loading packages\n\nWe will start by loading core packages for working with geographic vector and attribute data.\nSee detailed description of [R](https://ogh23.robinlovelace.net/tidy#vector-data) and [Python](https://geobgu.xyz/presentations/p_2023_ogh/01-vector.html) implementations in the respective lecture note sections.\n\n::: {.panel-tabset group=\"language\"}\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport pandas as pd\nfrom shapely import Point\nimport geopandas as gpd\n```\n:::\n\n\n## R\n\n<!---\n jn: I would suggest to use specific packages from tidyverse instead of attaching the whole tidyverse \n\nrl: Why? Tidyverse is popular and it makes life easy.\nAlso that's the approach in the teaching materials.\nFor the book and for software development that's another matter but for this blog post I think it's fine.\n--->\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sf)\nlibrary(tidyverse)\nlibrary(tmap)\n```\n:::\n\n\n:::\n\n## Creating geographic data\n\nThe following commands create geographic datasets 'from scratch' representing coordinates of a the faculty where the Summer School takes place, and few hotels, in Poznan, Poland.\nMost projects start with pre-generated data, but it's useful to create datasets to understand data structures.\n\n::: {.panel-tabset group=\"language\"}\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\npoi = gpd.GeoDataFrame([\n    {\"name\": \"Faculty\",        \"geometry\": Point(16.9418, 52.4643)},\n    {\"name\": \"Hotel ForZa\",    \"geometry\": Point(16.9474, 52.4436)},\n    {\"name\": \"Hotel Lechicka\", \"geometry\": Point(16.9308, 52.4437)},\n    {\"name\": \"FairPlayce\",     \"geometry\": Point(16.9497, 52.4604)},\n], crs=4326)\n```\n:::\n\n\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\npoi_df = tribble(\n  ~name, ~lon, ~lat,\n  \"Faculty\",        16.9418, 52.4643,\n  \"Hotel ForZa\",    16.9474, 52.4436,\n  \"Hotel Lechicka\", 16.9308, 52.4437,\n  \"FairPlayce\",     16.9497, 52.4604\n)\npoi_sf = sf::st_as_sf(poi_df, coords = c(\"lon\", \"lat\"), crs = \"EPSG:4326\")\n```\n:::\n\n\n:::\n\n### Downloading data\n\nThe following commands download data from the internet.\n\n::: {.panel-tabset group=\"language\"}\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport urllib.request\nimport zipfile\nimport os\nu = \"https://github.com/Robinlovelace/opengeohub2023/releases/download/data/data.zip\"\nf = os.path.basename(u)\nif not os.path.exists(\"data\"):\n    urllib.request.urlretrieve(u, f)\n```\n:::\n\n\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nu = \"https://github.com/Robinlovelace/opengeohub2023/releases/download/data/data.zip\"\nf = basename(u)\nif (!dir.exists(\"data\")) {\n  download.file(u, f)\n}\n```\n:::\n\n\nNote that we can read directly from ZIP files with R and Python thanks to the [GDAL Virtual File System](https://gdal.org/user/virtual_file_systems.html).\n\n:::\n\n## Unzipping data\n\nWe can unzip the data in R and Python: it contains spatial information about bus stops.\n\n::: {.panel-tabset group=\"language\"}\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\nwith zipfile.ZipFile(f, 'r') as zip_ref:\n    zip_ref.extractall()\n```\n:::\n\n\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nunzip(f)\n```\n:::\n\n\n:::\n\n## Reading and printing geographic data\n\nAs shown below, Python and R implemenations to import a shapefile are similar.\nNote: we recommend using open file formats such as GeoPackage (`.gpkg`), as outlined in [Geocomputation with R](https://r.geocompx.org/read-write) and [Geocomputation with Python](https://py.geocompx.org/08-read-write-plot).\n\n::: {.panel-tabset group=\"language\"}\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\npol_all = gpd.read_file(\"zip://data.zip!data/osm/gis_osm_transport_a_free_1.shp\")\npol_all\n```\n:::\n\n\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\npol_all = sf::read_sf(\"/vsizip/data.zip/data/osm/gis_osm_transport_a_free_1.shp\")\npol_all\n```\n:::\n\n\n:::\n\nNote: in R, you can read-in the dataset from the URL in a single line of code without first downloading the zip file:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nuz = paste0(\"/vsizip//vsicurl/\", u, \"/data/osm/gis_osm_transport_a_free_1.shp\")\npol_all = sf::read_sf(uz)\n```\n:::\n\n\n## Subsetting by attributes\n\nThe following commands select a subset of the data based on attribute values (looking for a specific string in the `name` column).\n\n::: {.panel-tabset group=\"language\"}\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\npol = pol_all[pol_all['name'].str.contains('Port*.+Poz', na=False)]\npol\n```\n:::\n\n\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\npol = pol_all |>\n  filter(str_detect(name, \"Port*.+Poz\"))\npol\n```\n:::\n\n\n:::\n\n## Basic plotting\n\nThe following commands plot the data.\nNote that by default, R's `plot()` method for `{sf}` objects creates a plot for each column in the data (up to 9 by default). <!--- Perhaps switch to plot(st_geometry(pol)) in R, to make it more comparable with Python? --->\n\n::: {.panel-tabset group=\"language\"}\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\npol.plot();\n```\n:::\n\n\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(pol)\n```\n:::\n\n\n:::\n\nThe arguments needed to change the colour of the fill and border are different in R and Python, but the results are similar.\n\n::: {.panel-tabset group=\"language\"}\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\npol.plot(color='none', edgecolor='black');\n```\n:::\n\n\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(st_geometry(pol), col = \"white\", border = \"black\")\n```\n:::\n\n\n:::\n\n## Creating geographic data frames from a CSV file\n\nThe following commands create a geographic data frame from a CSV file.\nNote that two steps---creating the geometry column and combining it with the original table, hereby combined into one complex expression---are needed to convert a `DataFrame` to a `GeoDataFrame` in Python, whereas in R the `sf::st_as_sf()` function can be used to convert a `data.frame` to a spatial data frame directly.\n\n::: {.panel-tabset group=\"language\"}\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Unzip the data.zip file:\nwith zipfile.ZipFile(f, 'r') as zip_ref:\n    zip_ref.extractall(\"data\")\nstops = pd.read_csv(\"data/gtfs/stops.txt\")\nstops = gpd.GeoDataFrame(\n    stops.drop(columns=['stop_lon', 'stop_lat', 'stop_code']),\n    geometry = gpd.points_from_xy(stops.stop_lon, stops.stop_lat),\n    crs = 4326)\nstops\n```\n:::\n\n\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstops = read_csv(\"data/gtfs/stops.txt\") |>\n  select(-stop_code) |>\n  st_as_sf(coords = c(\"stop_lon\", \"stop_lat\"), crs = \"EPSG:4326\")\nstops\n```\n:::\n\n\n:::\n\n## Plotting attributes and layers\n\nThe following commands plot the bus stops loaded in the previous step.\nNote that the **tmap** package is hereby used in R to create these more advanced plots, as it also supports interactive mapping (see below).\n\n::: {.panel-tabset group=\"language\"}\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\nstops.plot(markersize=1, column='zone_id', legend=True);\n```\n:::\n\n\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(stops) +\n  tm_symbols(size = 0.1, col = \"zone_id\")\n```\n:::\n\n\n:::\n\nWe can add basic overlays in both languages as follows.\n\n::: {.panel-tabset group=\"language\"}\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\nbase = stops.plot(markersize=0.1)\npoi.plot(ax=base, color='red');\n```\n:::\n\n\n## R\n\n<!---\n jn: should the next example use tmap instead of base R? \n--->\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(stops$geometry, col = \"grey\", pch = 20, cex = 0.5)\nplot(poi_sf$geometry, col = \"red\", add = TRUE)\n```\n:::\n\n\n:::\n\n## Interactive plots\n\nThe following commands create interactive plots, in Python and R respectively.\nThe Python code requires the **folium** and **mapclassify** packages, which are not installed by default when you install **geopandas**.\nNote that with **tmap**, you can use the same code to create static and interactive plots, by changing the `tmap_mode()`. \n\n::: {.panel-tabset group=\"language\"}\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\nstops.explore(column='zone_id', legend=True, cmap='Dark2')\n```\n:::\n\n\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"view\")\ntm_shape(stops) +\n  tm_symbols(size = 0.1, col = \"zone_id\")\n```\n:::\n\n\n:::\n\n## Reprojecting data\n\nThe following commands reproject the data to a local projected Coordinate Reference System (CRS).\n\n::: {.panel-tabset group=\"language\"}\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\npoi.crs\npoi_projected = poi.to_crs(2180)\nstops_projected = stops.to_crs(2180)\n```\n:::\n\n\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_crs(poi_sf)\npoi_projected = st_transform(poi_sf, 2180)\nstops_projected = st_transform(stops, 2180)\n```\n:::\n\n\n:::\n\n## Buffers\n\nThe following commands create buffers around the points.\nNote that R allows buffer to be created directly from a spatial data frame with geographic (lon/lot) coordinates thanks to its integration with Google's S2 spherical geometry engine, as outlined in [Geocomputation with R](https://r.geocompx.org/reproj-geo-data#geom-proj).\nFor buffer operations to work in Python you must reproject the data first (which we did, see above) (although there are plans for **geopandas** to support a spherical geometry backend at some point, as discussed in issue [#2098](https://github.com/geopandas/geopandas/issues/2098)).\n\n::: {.panel-tabset group=\"language\"}\n\n## Python\n\n<!---\n TODO: can we improve this? \n--->\n\nTo create a new vector layers named `poi_buffer`, in both languages, we can do the following.\n\n\n::: {.cell}\n\n```{.python .cell-code}\npoi_buffer = poi.copy()\npoi_buffer.geometry = poi_projected.buffer(150).to_crs(4326)\n```\n:::\n\n\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\npoi_buffer = st_buffer(poi_sf, 150)\n```\n:::\n\n\n:::\n\n## Calculating distances and areas\n\nAn interesting difference between R and Python is that the former uses the `units` package to store units, making it easy to convert between them, as outlined in the [buffers section of the R lecture notes](https://ogh23.robinlovelace.net/tidy#buffers). \n\n::: {.panel-tabset group=\"language\"}\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\npoi_buffer.to_crs(2180).area\n```\n:::\n\n\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_area(poi_buffer)\n```\n:::\n\n\n:::\n\n## Spatial subsetting\n\nCode to subset the bus stops within the buffered `poi` points is shown below.\nThe R code is more concise because there is a special `[` notation for the specific case of subsetting by intersection. In Python you must undertake the explicit steps, which are applicable to any predicate in both languages:\n\n- Take the unary union of the buffered points before subsetting\n- Create a boolean `Series` object with the `.intersects` or other method, and use the boolean Series to subset the data (rather than another geographic object)\n\n::: {.panel-tabset group=\"language\"}\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\npoi_union = poi_buffer.unary_union\nsel = stops.intersects(poi_union)\nstops_in_b = stops[sel]\nstops_in_b\n```\n:::\n\n\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstops_in_b = stops[poi_buffer, ]\nstops_in_b\n```\n:::\n\n\n:::\n\n## Spatial joins\n\nSpatial joins are implemented with similar functions in R and Python and the outputs are the same.\nSee the [Python](https://geobgu.xyz/presentations/p_2023_ogh/01-vector.html#sec-spatial-join) and R tutorials, and in Geocomputation with R Section [4.2.4](https://r.geocompx.org/spatial-operations#spatial-joining) and Geocomputation with Python [3.3.4](https://py.geocompx.org/04-spatial-operations#sec-spatial-joining) for more details.\n\n::: {.panel-tabset group=\"language\"}\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\npoi_buffer.sjoin(stops, how='left')\n```\n:::\n\n\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_join(poi_buffer, stops)\n```\n:::\n\n\n:::\n\n\n::: {.cell}\n\n:::\n\n\n# Questions and next steps\n\nThe code above shows that R and Python are similar in many ways.\nDifferences include:\n\n- R's package **sf** use of the S2 spherical geometry engine by default for lon/lat data, which can mean fewer lines of code for some operations (e.g. buffers)\n- The R package **sf** returns measures with units, which can make conversions easier, but which can also be confusing for new users\n- Python uses the 'zip:' syntax for virtual file system access, while R uses '/vsizip/'\n- Python has native support for interactive plotting with the `.explore()` method, while R requires an additional package such as **tmap** or **mapview** to create interactive plots\n\nThe above code is also a good example of how to create a reproducible workflow for geographic data analysis.\nWe hope that it can also act a bit like a [Rosetta Stone](https://en.wikipedia.org/wiki/Rosetta_Stone) for those who are familiar with one language and want to learn the other.\n\nIt also raises some questions, which we leave unanswered for the community to consider and comment on:\n\n- Which language is more concise?\n  - While there are slightly fewer lines of R code in the examples above, there may be ways to improve the Python code\n- Which language runs quicker?\n    - It would be interesting to see benchmarks for the above code, perhaps in a future [geocompx](https://geocompx.org/) blog post or even a multi-language benchmarking package\n- Which language is quicker to write code in (the answer likely depends on your prior experience and tastes)?\n\nWe welcome input on these questions and any other comments on the above code, the source code of which can be found at [github.com/geocompx/geocompx.org](https://github.com/geocompx/geocompx.org/blob/main/post/2023/rgdal-retirement/index.qmd).\nIf you would like to contribute, with ideas, comments, or additional questions, feel free to get in touch via the [geocompx](https://geocompx.org/) website, our [Discord server](https://discord.gg/PMztXYgNxp), in a [GitHub Discussion](https://github.com/orgs/geocompx/discussions), on [Mastodon](https://fosstodon.org/tags/geocompx) or anywhere else.\n\n# Further reading\n\nThere is lots more to learn in this space.\nFor more information, the following resources are recommended:\n\n- [Geocomputation with R](https://r.geocompx.org/) \n- [Geocomputation with Python](https://py.geocompx.org/)\n- [Spatial Data Science with applications in R and Python](https://r-spatial.org/python/), which provides R and Python code side-by-side\n- A great tutorial that simultaneously covers R and Python is [Tools and packages to query and process Sentinel-1 and Sentinel-2 data with R and Python](https://github.com/loreabad6/ogh23) by Lorena Abad.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}