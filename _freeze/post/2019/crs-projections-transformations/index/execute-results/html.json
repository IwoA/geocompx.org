{
  "hash": "9d9f5f88964bf96a0e23258174b06f8c",
  "result": {
    "markdown": "---\ntitle: 'Geographic projections and transformations'\nauthor: Robin Lovelace\ndate: '2019-08-21'\ncategories:\n  - vignette\ntags:\n  - geocompr\n  - rspatial\n  - sf\n  - crs\npublishDate: 2019-07-16\n---\n\n::: {.cell}\n\n:::\n\n\n# Introduction\n\nThis workbook outlines key concepts and functions related to map projections --- also referred to as coordinate reference systems (CRSs) --- and transformation of geographic data from one projection to another.\nIt is based on the open source book [*Geocomputation with R*](https://geocompr.robinlovelace.net), and Chapter [6](https://geocompr.robinlovelace.net/reproj-geo-data.html) in particular.\n\nIt was developed for the '[CASA Summer School](https://bonnie-buyuklieva.github.io/SS_ASM19/)', or the Doctoral Summer School for Advanced Spatial Modelling: Skills Workshop and Hackathon, 21^st^ to 23^rd^ August 2019, for its full name!\nIt should be of use to anyone interested in projections, beyond the summer school, so we posted it on our newly updated [website](https://geocompr.github.io/) for maximum benefit.\n\n# Prerequisites {-}\n\nBefore you get started, make sure you have the packages installed:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sf)\nlibrary(dplyr)\nlibrary(spData)\n```\n:::\n\n\n# Introduction\n\nBefore we get started, why use R for geographic data?\n\nSimple answer: because it works, excels at spatial statistics and visualisation and has a huge user community.\n\nIt can be used for a wide range of things such as:\n\n- Book on Geocomputation: https://geocompr.robinlovelace.net/\n- Propensity to Cycle Tool: https://pct.bike/\n\nGeographic data relies on a frame of reference.\nThere are two main types of CRS:\n\n- **Geographic**, where the frame of reference is the globe and how many degrees north or east from the position (0, 0) you are\n- **Projected**, where the frame of reference is a flat representation of part of the Earth's surface\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Illustration of vector (point) data in which location of London (the red X) is represented with reference to an origin (the blue circle). The left plot represents a geographic CRS with an origin at 0° longitude and latitude. The right plot represents a projected CRS with an origin located in the sea west of the South West Peninsula.](https://geocompr.robinlovelace.net/figures/vector_lonlat.png){fig-scap='Illustration of vector (point) data.' width=49%}\n:::\n\n::: {.cell-output-display}\n![Illustration of vector (point) data in which location of London (the red X) is represented with reference to an origin (the blue circle). The left plot represents a geographic CRS with an origin at 0° longitude and latitude. The right plot represents a projected CRS with an origin located in the sea west of the South West Peninsula.](https://geocompr.robinlovelace.net/figures/vector_projected.png){fig-scap='Illustration of vector (point) data.' width=49%}\n:::\n:::\n\n\n# TLDR\n\nThe 'too long didn't read' (TLDR) take away messages from this text are:\n\n- **Be aware of projections**\n- **Decide an appropriate CRS for your project and ensure everything is in that CRS**\n- **Use a projected CRS when doing geometric operations**\n- **EPSG codes such as 27700 and 4326 refer to specific coordinate systems**\n- **It is worth checking if there is an officially supported projection for the region --- that is often a good option**\n\nIn R, you can check, set and transform CRS with `st_crs()` and `st_transform()` as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nzones_london = lnd\nst_crs(zones_london)                                         # find out the CRS\n#> Coordinate Reference System:\n#>   User input: EPSG:4326 \n#>   wkt:\n#> GEOGCS[\"WGS 84\",\n#>     DATUM[\"WGS_1984\",\n#>         SPHEROID[\"WGS 84\",6378137,298.257223563,\n#>             AUTHORITY[\"EPSG\",\"7030\"]],\n#>         AUTHORITY[\"EPSG\",\"6326\"]],\n#>     PRIMEM[\"Greenwich\",0,\n#>         AUTHORITY[\"EPSG\",\"8901\"]],\n#>     UNIT[\"degree\",0.0174532925199433,\n#>         AUTHORITY[\"EPSG\",\"9122\"]],\n#>     AUTHORITY[\"EPSG\",\"4326\"]]\nzones_london_projected = st_transform(zones_london, 27700)   # transform CRS\nst_crs(zones_london) = NA                                    # set CRS\nst_crs(zones_london) = 4326                                  # set CRS\n```\n:::\n\n\nIf you ignore CRSs, bad things can happen.\n\n# Why are projections needed?\n\nWithout a coordinate system, we have no context:\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\nWhich country is it?\n\nLocation on Earth is measured in degrees so, even when axes are equal, maps are highly distorted representations of reality far from the equator:\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\nAlong which axis is the image over-represented?\n\nEven when we compensate for this, the cylindrical projection is misleading:\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\nBy default, most software (including R) plots data with geographic lon/lat coordinates a cylindrical projection, leading to maps like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(canada$geom)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n\n```{.r .cell-code}\nplot(world)\n#> Warning: plotting the first 9 out of 10 attributes; use max.plot = 10 to plot\n#> all\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-2.png){width=672}\n:::\n:::\n\n\nAcross the whole world, the results look like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(st_geometry(world), col = \"grey\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\nThere is no single 'correct' CRS that can represent everywhere well: it is physically impossible to 'peal' the surface of the Earth onto a flat screen (credit: [Awar Jahfar](https://unsplash.com/@awarnerway)):\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](https://images.unsplash.com/photo-1564509398619-622e40ad5a5e?ixlib=rb-1.2.1&auto=format&fit=crop&w=633&q=80)\n:::\n:::\n\n\n> At best we can comply with two out of three spatial properties (distance, area, direction).\nTherefore, the task at hand determines which projection to choose. \nFor instance, if we are interested in a density (points per grid cell or inhabitants per grid cell), we should use an equal-area projection.\n\n- There is also a fourth property, shape.\n\n# Which projection to use?\n\nA range of CRSs is available:\n\n- A Lambert azimuthal equal-area ([LAEA](https://en.wikipedia.org/wiki/Lambert_azimuthal_equal-area_projection)) projection for a custom local projection (set `lon_0` and `lat_0` to the center of the study area), which is an equal-area projection at all locations but distorts shapes beyond thousands of kilometers.\n-  Azimuthal equidistant ([AEQD](https://en.wikipedia.org/wiki/Azimuthal_equidistant_projection)) projections for a specifically accurate straight-line distance between a point and the center point of the local projection.\n- Lambert conformal conic ([LCC](https://en.wikipedia.org/wiki/Lambert_conformal_conic_projection)) projections for regions covering thousands of kilometers, with the cone set to keep distance and area properties reasonable between the secant lines.\n- Stereographic ([STERE](https://en.wikipedia.org/wiki/Stereographic_projection)) projections for polar regions, but taking care not to rely on area and distance calculations thousands of kilometers from the center.\n\nThis is how it works in R:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nworld_laea1_g = world %>%\n  st_transform(\"+proj=laea +x_0=0 +y_0=0 +lon_0=0 +lat_0=0\") %>% \n  st_geometry()\nplot(world_laea1_g)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nworld %>%\n  st_transform(\"+proj=aeqd +x_0=0 +y_0=0 +lon_0=0 +lat_0=0\") %>% \n  st_geometry() %>% \n  plot()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nworld %>%\n  st_transform(\"+proj=moll\") %>% \n  st_geometry() %>% \n  plot()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\nHow to add graticules?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nworld %>%\n  st_transform(\"+proj=moll\") %>% \n  st_geometry() %>% \n  plot()\ng = st_graticule(x = world) %>% \n  st_transform(\"+proj=moll\") %>% \n  st_geometry()\nplot(g, add = TRUE)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncanada_centroid = st_coordinates(st_centroid(canada))\n#> Warning in st_centroid.sf(canada): st_centroid assumes attributes are constant\n#> over geometries of x\ncanada_laea_crs = paste0(\"+proj=laea +x_0=0 +y_0=0 +lon_0=\",\n                         canada_centroid[1],\n                         \" +lat_0=\",\n                         canada_centroid[2])\ncanada_laea = st_transform(canada, crs = canada_laea_crs)\nworld_laea = st_transform(world, crs = canada_laea_crs)\nplot(st_geometry(canada_laea))\nplot(world_laea, add = TRUE)\n#> Warning in plot.sf(world_laea, add = TRUE): ignoring all but the first attribute\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncanada_centroid = st_coordinates(st_centroid(canada))\n#> Warning in st_centroid.sf(canada): st_centroid assumes attributes are constant\n#> over geometries of x\ncanada_laea_crs = paste0(\"+proj=laea +x_0=0 +y_0=0 +lon_0=\",\n                         canada_centroid[1],\n                         \" +lat_0=\",\n                         canada_centroid[2])\ncanada_laea = st_transform(canada, crs = canada_laea_crs)\nworld_laea = st_transform(world, crs = canada_laea_crs)\nplot(st_geometry(canada_laea))\nplot(world_laea, add = TRUE)\n#> Warning in plot.sf(world_laea, add = TRUE): ignoring all but the first attribute\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\n# EPSG codes\n\nEPSG codes are standard codes for projections.\nSee them in R with:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nepsg_codes = rgdal::make_EPSG()\n# View(epsg_codes) # open in interactive spreadsheet\n```\n:::\n\n\nIn the UK, the EPSG code of official data is [27700](https://epsg.io/27700).\n\n# Geographic data in R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlondon_df = data.frame(name = \"london\", population = 1e7,\n                       lon = -0.1, lat = 51.5)\nclass(london_df)\n#> [1] \"data.frame\"\nlondon = st_as_sf(london_df, coords = c(\"lon\", \"lat\"))\nclass(london)\n#> [1] \"sf\"         \"data.frame\"\nst_is_longlat(london)\n#> [1] NA\nplot(zones_london_projected$geometry)\nplot(london$geometry, add = TRUE, pch = 9) # not there\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\n# Issues with geometric operations\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlondon_buff1 = st_buffer(london, 0.1)\nplot(london_buff1)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n\n```{.r .cell-code}\nplot(zones_london$geometry)\nplot(london_buff1, add = T)\n#> Warning in plot.sf(london_buff1, add = T): ignoring all but the first attribute\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-16-2.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nst_crs(london) = 4326\nlondon_projected = st_transform(london, 27700)\nlondon_buff2 = st_buffer(london_projected, 10000)\nst_is_longlat(london_projected)\n#> [1] FALSE\nplot(zones_london_projected$geometry)\nplot(london_buff2, add = TRUE)\n#> Warning in plot.sf(london_buff2, add = TRUE): ignoring all but the first\n#> attribute\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\n# Further reading\n\nIf you're interested in learning more on this, check out *Geocomputations with R*.\n\n[![](https://geocompr.robinlovelace.net/images/cover.png)](https://geocompr.robinlovelace.net/)\n\nMore specific resources on projections include:\n\n- Excellent tutorial on coordinate systems on the Manifold website: http://www.manifold.net/doc/mfd9/projections_tutorial.htm\n- An introduction to vector geographic data in *Geocomputation with R* (Section [2.2](https://geocompr.robinlovelace.net/spatial-class.html#vector-data))\n- An introduction to CRSs in R (Section [2.4](https://geocompr.robinlovelace.net/spatial-class.html#crs-intro))\n- The contents and exercises of Chapter [6](https://geocompr.robinlovelace.net/reproj-geo-data.html), solutions to which you can find at https://geocompr.github.io/geocompkg/articles/index.html\n- For a fun take on projections, see https://xkcd.com/977/\n- Chapter in upcoming book on CRSs by Edzer Pebesma and Roger Bivand: https://github.com/edzer/sdsr\n\nCheck out the questions in the exercises section of Chapter 6 of Geocomputation with R.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}